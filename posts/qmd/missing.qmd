---
title: "Tips from ./missing-semester"
subtitle: Things I learned from MIT's "Missing Semester of Your CS Education" course.
format: 
  html:
    code-line-numbers: true
    number-sections: true
image: ../img/missing.png
---

This some fun stuff I picked up from the 2020 offering of the fantastic [./missing-semester](https://missing.csail.mit.edu/) class at MIT. 

Enjoy!

## [Shell basics](https://missing.csail.mit.edu/2020/course-shell/)

### Redirection and piping

- `>` and `<` redirect output from and to a file or stream.
- `x < y` redirects `y` as input to `x`. 
- `x > y` redirects output of `x` to `y`.
- `<<` and `>>` will append as opposed to overwrite.
- `|` chains program together.

### Use single quotations to nullify meaning

> Enclosing characters in single quotes (‘'’) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash.[^1]

[^1]: <https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html>

### sudo

`sudo` stands for "super user do".

## [Shell tools and scripting](https://missing.csail.mit.edu/2020/shell-tools/)

### Setting variables

Set variable using `x=[value]` with no spaces between anything.

Access it with `echo $x`.

### Bash scripts

We can write a bash script by copying the following into `mcd.sh`:

```{{bash}}
mcd () {
  mkir -p "$1"
  cd "$1"
}
```

`$1` refers to the first positional argument the function recieves. Putting double quotations around it ensures that names that contain a space don't accidently get truncated.

If you load this function into the terminal with `source mcd.sh` you can run it using `mcd [dirname]`.

Some more variable names:

|Command|Description|
|---|---|
|`$1` to `$9`|First 9 positional arguments (use `${i}` to access argumennts past the 9th).|
|`$0`|Name of the filename that the script is being run from (will be `/bin/bash` for the example above.)|
|`$_`|Last argument of the last command. So we could have changed line 3 above to `cd "$_"`.|
|`$#`|Number of arguments passed in.|
|`!!`|Reruns the previous command. Useful for redoing things that failed due to permissions: `sudo !!`.|
|`$?`|Exit code of the previous command. You can use it to catch errors with `||` and `&&`[^2].|

[^2]: <https://www.gnu.org/software/bash/manual/bash.html#Lists>

### Command substitution

You can store the output of a command into a variable using parentheses. For instance, `x=(pwd)` will save your working directory into `x`.

**Process substitution** lets you pass command output into commands that expect a file instead of STDIN: `cat <(ls) <(ls ..)` will concatenate the contents of the current directory with that of its parent directory.

### Globbing

Grab files names using patterns with wildcards:

|Wildcard|Description|
|---|---|
|`?`|Matches one position: `x?` matches `x1` but not `x10`.|
|`*`|Matches multiple positions: `x*` matches `x1` and `x10`.|
|`{}`|Perform expansion of all values. Use multiple for Cartesian product; e.g. `echo {1,2}{3,4}` returns `13 14 23 24`. Use `{x..y..i}` to go from `x` to `y` with increment `i`.|

### Useful shell commands

|Command|Description|Example|
|---|---|---|
|`spellcheck`|Analyze shell scripts for errors and bugs.|`spellcheck script.sh`|
|`tldr`|Get concise help pages (with examples!).|`tldr [command]`|
|`find`|Find files recursively in a folder.|`find [dir] -name '[filename|*.ext]'`|

`find` can also process the results:

```{{bash}}
# Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;
```

### Alternatives to `find`

Here are some options for extra functionality:

|Command|Benefit|
|---|---|
|`fd`|Modernized implementation with simpler syntax.|
|`locate`|Faster lookup via file indexing (updated by `updatedb`).|
|`grep`|Search the content of files.|
|`rg` (ripgrep)|Faster, modernized `grep`.|
|`rga`|Use `rg` on PDFs, and other documents.|

### Finding shell commands

Use `history` to avoid re-typing commands:

|Command|Description|
|---|---|
|`history`|Returns all commands that you ran.|
|`history [n]`|Returns the last n commands.|
|`history | rg [search term]`| Searches through commands.|
|`<ctrl>-r`|Built-in search.`<ctrl>-r` to cycle through entries and `<ctrl>-c` to cancel the search.|

You can improve `<ctrl>-r` by incorporating `fzf` to add fuzzy matching. Learn how with this command:

```{{bash}}
cat $(rg README <(apt show fzf) | cut -d ' ' -f 3)
```

Hopefully it makes sense to you based on what you've read so far! 

### Directory navigation

Commands to view files:

|Command|Description|
|---|---|
|`tree`|Basic tree visualizer.|
|`broot`|Nicer tree UI.
|`nnn`|Mac-style explorer.|

## [Editors (Vim)](https://missing.csail.mit.edu/2020/editors/)

### Modes 

Vim is based on different _modes_: 

|Mode|How to enter|
|---|---|
|`NORMAL`|`<esc>`|
|`INSERT`|`i`|
|`REPLACE`|`R`|
|`VISUAL`|`v`|
|`V-LINE`|`<shift>-v`|
|`V-BLOCK`|`<ctrl>-v`|
|`COMMAND-LINE`|`:`|

### Movement

Move around quickly using these commands:

|Command|Description|
|---|---|
|`j/k`|Down/up.|
|`h/l`|Left/right.|
|`w`|Next word.|
|`b/e`|Beginning/end of word.|
|`0/$/^`|Move to beginning/end/first non-empty character of line.|
|`gg/G`|Beginning/end of file.|
|`H/M/L`|Top/middle/bottom of screen.|
|`<ctrl>-u/d`|Page up/down.|
|`[number]G`|Go to line.|
|`%`|Go to corresponding parenthesis, bracket, etc.|
|`f/F`|Find a character forward/backward. Navigate back and forth with `,/;`.|
|`t/T`|Like `find` but up until the character instead of on it.|

You can do a lot of the movement commands n times, e.g. `[n]w` to go forward n words.

### Editing

These are the basic editing commands:

|Command|Description|
|---|---|
|`a`|Append to current position.|
|`A`|Append to end of current line.|
|`r`|Replace one character.|
|`R`|`REPLACE` mode.|
|`d`|Delete.|
|`c`|Delete movement and switch to insert mode.|
|`x/X`|Delete a character forwards/backwards.|
|`s`|Delete a character and switch to insert mode.|
|`S`|Delete a line and switch to insert mode.|

Editing commands can modified via movement commands, e.g. `dw` will delete a word, and `d[n]w` will delete n words.

Quickly duplicate a line with `yy p`.

### Modifiers

|Modifier|Description|
|---|---|
|`a`|Around.|
|`i`|Inner.|

Modifiers change the meaning of a command.

So `ci(` will delete the contents inside a pair of parentheses, while `ca(` will include the parentheses.

Modifiers can also be used in visual mode: `vas` will select the current sentence, `vap` the paragraph, and `va(` the parenthetical block.

### Find

Find things with `/` followed by what you are looking for. Pressing `<enter>` will jump you to the closest occurrence. `n/N` cycle forwards/backwards through the results.

## [Data wrangling](https://missing.csail.mit.edu/2020/data-wrangling/)

### Stream editing

Streams are sequences of elements that come in one at a time.
  
There are a number of commands you can use to process streams:

|Command|Description|Syntax|
|---|---|---|
|`sed`|Process text in place using regex. Use `s` for text substitution and `-E` for modern syntax**.|`sed -E s/[pattern]/[replacment]/[flag]`|
|`awk`|Process columnar data. Access the columns using `$n`. Using `BEGIN` and `END` enable stateful behavior.|`awk 'command'`|
|`xargs`|Takes lines of inputs and turns them into command arguments.|`[STDOUT] | xargs [command]`|

Also worth mentioning:

* `sort`
* `uniq` (requires a sorted list; `-c` to include counts)
* `paste` (`-s` to concatenate columns and `-d` to change the delimiter)
* `head`/`tail`
* `bc` (calculator! Use with `-l` to read STDIN).

### Regex

Regular expressions is a language for expressing text patterns. Here are some common building blocks:

|Expression|Description|
|---|---|
|`.`|Any character.|](https://missing.csail.mit.edu/2020/editors/)
|`[...]`|A set of characters.|
|`[^...]`|The opposite of the set.|
|`(x|u|...)`|A set of strings.|
|`(...)*`|0 or more.|
|`(...)+`|1 or more.|
|`(...)?`|0 or 1.|
|`(...){n}`|N times.|
|`(...){n,}`|N or more times.|
|`(...){n, m}`|N to m times.|
|`^`|Anchor for beginning of string.|
|`$`|Anchor for end of string.|

Adding `?` suffix to quantifiers (`*`, `+`, `?`, `{n}`, `{n,}`, `{n, m}`) will toggle **lazy** and match to the leftmost character. Quantifiers are **greedy** by default, meaning they will match the rightmost character, which can lead to unintended matches. 

Create a **capture group** around an expression using parentheses `()`. Then you can select it positionally in a replace statement using `\n` to indicate the nth group:

```{{bash}}
# Return just the filenames from a list of PDFs.
ls *.pdf | sed -E 's/^(.+).pdf$/\1/'
```

