---
title: "Tips from ./missing-semester"
subtitle: Things I learned from MIT's "Missing Semester of Your CS Education" course.
format: 
  html:
    code-line-numbers: true
    number-sections: true
    toc: true
    toc-title: Lectures
image: ../img/missing.png
---

This some fun stuff from the 2020 offering of the fantastic [./missing-semester](https://missing.csail.mit.edu/) class at MIT.

Enjoy!

## Shell basics

### Use redirection and piping to link commands together

- `>` and `<` redirect output from and to a file or stream.
- `x < y` redirects `y` as input to `x`. 
- `x > y` redirects output of `x` to `y`.
- `<<` and `>>` will append as opposed to overwrite.
- `|` chains program together.

### Use single quotations to nullify meaning

> Enclosing characters in single quotes (‘'’) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash.[^1]

[^1]: <https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html>

### sudo

`sudo` stands for "super user do".

## Shell tools and scripting

### Save values by setting variables

Set variable using `x=[value]` with no spaces between anything.

Access it with `echo $x`.

### How to write bash scripts

We can write a bash script by copying the following into `mcd.sh`:

```{{bash}}
mcd () {
  mkir -p "$1"
  cd "$1"
}
```

`$1` refers to the first positional argument the function recieves. Putting double quotations around it ensures that names that contain a space don't accidently get truncated.

If you load this function into the terminal with `source mcd.sh` you can run it using `mcd [dirname]`.

Some more variable names:

|Command|Description|
|---|---|
|`$1` to `$9`|First 9 positional arguments (use `${i}` to access argumennts past the 9th).|
|`$0`|Name of the filename that the script is being run from (will be `/bin/bash` for the example above.)|
|`$_`|Last argument of the last command. So we could have changed line 3 above to `cd "$_"`.|
|`$#`|Number of arguments passed in.|
|`!!`|Reruns the previous command. Useful for redoing things that failed due to permissions: `sudo !!`.|
|`$?`|Exit code of the previous command. You can use it to catch errors with `||` and `&&`[^2].|

[^2]: <https://www.gnu.org/software/bash/manual/bash.html#Lists>

### Command substitution saves output to a variable

For instance, `x=(pwd)` will save your working directory into `x`.

**Process substitution** lets you pass command output into commands that expect a file instead of STDIN: `cat <(ls) <(ls ..)` will concatenate the contents of the current directory with that of its parent directory.

### Grab files names using patterns with globbing wildcards

|Wildcard|Description|
|---|---|
|`?`|Matches one position: `x?` matches `x1` but not `x10`.|
|`*`|Matches multiple positions: `x*` matches `x1` and `x10`.|
|`{}`|Perform expansion of all values. Use multiple for Cartesian product; e.g. `echo {1,2}{3,4}` returns `13 14 23 24`. Use `{x..y..i}` to go from `x` to `y` with increment `i`.|

### Useful misc. shell commands

|Command|Description|Example|
|---|---|---|
|`spellcheck`|Analyze shell scripts for errors and bugs.|`spellcheck script.sh`|
|`tldr`|Get concise help pages (with examples!).|`tldr [command]`|
|`find`|Find files recursively in a folder.|`find [dir] -name '[filename|*.ext]'`|

`find` can also process the results:

```{{bash}}
# Delete all files with .tmp extension
find . -name '*.tmp' -exec rm {} \;
```

### Alternatives to `find` for extra functionality

|Command|Benefit|
|---|---|
|`fd`|Modernized implementation with simpler syntax.|
|`locate`|Faster lookup via file indexing (updated by `updatedb`).|
|`grep`|Search the content of files.|
|`rg` (ripgrep)|Faster, modernized `grep`.|
|`rga`|Use `rg` on PDFs, and other documents.|

### Avoid re-typing commands using `history`

|Command|Description|
|---|---|
|`history`|Returns all commands that you ran.|
|`history [n]`|Returns the last n commands.|
|`history | rg [search term]`| Searches through commands.|
|`<ctrl>-r`|Built-in search.`<ctrl>-r` to cycle through entries and `<ctrl>-c` to cancel the search.|

You can improve `<ctrl>-r` by incorporating `fzf` to add fuzzy matching. Learn how with this command:

```{{bash}}
cat $(rg README <(apt show fzf) | cut -d ' ' -f 3)
```

Hopefully it makes sense to you based on what you've read so far! 

### Directory navigation commands

|Command|Description|
|---|---|
|`tree`|Basic tree visualizer.|
|`broot`|Nicer tree UI.
|`nnn`|Mac-style explorer.|

## Editors (Vim)

### Vim operates in different modes 

|Mode|How to enter|
|---|---|
|`NORMAL`|`<esc>`|
|`INSERT`|`i`|
|`REPLACE`|`R`|
|`VISUAL`|`v`|
|`V-LINE`|`<shift>-v`|
|`V-BLOCK`|`<ctrl>-v`|
|`COMMAND-LINE`|`:`|

### Movement around swiftly using keyboard shortcuts

|Command|Description|
|---|---|
|`j/k`|Down/up.|
|`h/l`|Left/right.|
|`w`|Next word.|
|`b/e`|Beginning/end of word.|
|`0/$/^`|Move to beginning/end/first non-empty character of line.|
|`gg/G`|Beginning/end of file.|
|`H/M/L`|Top/middle/bottom of screen.|
|`<ctrl>-u/d`|Page up/down.|
|`[number]G`|Go to line.|
|`%`|Go to corresponding parenthesis, bracket, etc.|
|`f/F`|Find a character forward/backward. Navigate back and forth with `,/;`.|
|`t/T`|Like `find` but up until the character instead of on it.|

You can do a lot of the movement commands n times, e.g. `[n]w` to go forward n words.

### Edit text efficiently with commands

|Command|Description|
|---|---|
|`a`|Append to current position.|
|`A`|Append to end of current line.|
|`r`|Replace one character.|
|`R`|`REPLACE` mode.|
|`d`|Delete.|
|`c`|Delete movement and switch to insert mode.|
|`x/X`|Delete a character forwards/backwards.|
|`s`|Delete a character and switch to insert mode.|
|`S`|Delete a line and switch to insert mode.|

Editing commands can modified via movement commands, e.g. `dw` will delete a word, and `d[n]w` will delete n words.

Quickly duplicate a line with `yy p`.

### Modifiers select text within blocks

|Modifier|Description|
|---|---|
|`a`|Around.|
|`i`|Inner.|

Modifiers change the meaning of a command.

So `ci(` will delete the contents inside a pair of parentheses, while `ca(` will include the parentheses.

Modifiers can also be used in visual mode: `vas` will select the current sentence, `vap` the paragraph, and `va(` the parenthetical block.

### Find

Find things with `/` followed by what you are looking for. Pressing `<enter>` will jump you to the closest occurrence. `n/N` cycle forwards/backwards through the results.

## Data wrangling

### Stream editing processes sequences of elements
  
There are a number of commands you can use to process streams:

|Command|Description|Syntax|
|---|---|---|
|`sed`|Process text in place using regex. Use `s` for text substitution and `-E` for modern syntax**.|`sed -E s/[pattern]/[replacment]/[flag]`|
|`awk`|Process columnar data. Access the columns using `$n`. Using `BEGIN` and `END` enable stateful behavior.|`awk 'command'`|
|`xargs`|Takes lines of inputs and turns them into command arguments.|`[STDOUT] | xargs [command]`|

Also worth mentioning:

* `sort`
* `uniq` (requires a sorted list; `-c` to include counts)
* `paste` (`-s` to concatenate columns and `-d` to change the delimiter)
* `head`/`tail`
* `bc` (calculator! Use with `-l` to read STDIN).

### Regex is a language to capture text patterns

Here are some common building blocks:

|Expression|Description|
|---|---|
|`.`|Any character.|
|`[...]`|A set of characters.|
|`[^...]`|The opposite of the set.|
|`(x|y|...)`|A set of strings.|
|`(...)*`|0 or more.|
|`(...)+`|1 or more.|
|`(...)?`|0 or 1.|
|`(...){n}`|N times.|
|`(...){n,}`|N or more times.|
|`(...){n, m}`|N to m times.|
|`^`|Anchor for beginning of string.|
|`$`|Anchor for end of string.|

Adding `?` suffix to quantifiers (`*`, `+`, `?`, `{n}`, `{n,}`, `{n, m}`) will toggle **lazy** matching which will find the leftmost match. Quantifiers are **greedy** by default, meaning they will match the rightmost character, which can lead to unintended matches. 

Create a **capture group** around an expression using parentheses `()`. Then you can select it positionally in a replace statement using `\n` to indicate the nth group:

```{{bash}}
# Return just the filenames from a list of PDFs.
ls *.pdf | sed -E 's/^(.+).pdf$/\1/'
```

## Command-line environment

### Manage multiple processes using job control

You can control processes via standardized POSIX signals[^3] that interrupt, pause, background start, etc. programs: 

[^3]: Look up `man signal` for a comprehensive list of every signal.

|Shortcut|Description|
|---|---|
`<ctrl>-c`|`SIGINT`, interrupts the current process.
|`<ctrl>-\`|`SIGQUIT`, quits the process similar to `SIGINT`.|
|`<ctrl>-z`|`SIGSTOP`, suspends the current process.|

You can catch these signals to add functionality like saving program state when interrupted for instance.

There are also commands to manage unfinished processes:

|Command|Description|
|---|---|
|`jobs`|View unfinished jobs. `-l` to list PID (Process ID), `-p` only list PID, etc. (cf. `tldr jobs`).|
|`ps`|Get a snapshot of processes. Similar to `jobs`.|
|`bg %n/PID`|Continue unfinished job in the background using `%n` position in `jobs` queue or PID.|
|`fg %n\PID`|Bring a background process to the foreground and resume it if it was paused.|
|`kill %n/PID`|Terminate job.|
|`nohup`|Continue job even if terminal session is closed by by ignoring `SIGHUP` hangup signal.|
|`disown %n/PID`|`nohup` already running jobs from current session.|
|`[process] &`| Start command in background (will print to STDOUT unless redirected).|

`<ctrl>-z` followed by `bg` will send a currently running process to execute in the background.

### Multiplexers enable multitasking within a single session

`tmux`, a popular multiplexer provides the following hierarchy:

* **Sessions** are an independent workspace.
* **Windows** are like tabs within a workspace.
* **Panes** are individual splits within a window.

Once a session is started (`tmux new -s NAME`) commands are bound to `<ctrl>-b` (though a common modification is to remap to `<ctrl>-a`).

Then you can create new windows and rearrange panes. Use `<ctrl>-b + ?` for a list of options.

Also feel free to consult this [tutorial](https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/) and its [followup](https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/) on customization.

## Version control (Git)

### Git tracks data efficiently using hashing

If you press `git log` you will find that each commit has a long, random-looking string next to it. This string is called a hash and it links each commit to the data it represents.

A hash is a unique string generated by the content of a file. If the file changes, so does the hash. Git uses this fact to store files efficiently: only the files that have changed between commits get a new hash, while old files can still be accessed using the same hash value.

Commits contain the hash values of the root directory. The root directory itself points, via hash, to its contents and so on. This way, only the tree of references is updated and Git avoids having to copy the same files over and over again for each commit. This underlying hash-based data table is called content-addressed storage (CAS).

Use `git cat-file -p [commit hash]` to explore your commits!

### Useful Git commands

|Command|Description|
|---|---|
|`git clone --depth=1`|Clone a git repository without the commit history.|
|`git add -p [file]`|Select lines of code within a file to add (patch).|
|`git blame [file]`|See who and which commit authored each line of a file.|
|`git show [commit]`|Display what changed in each commit.|

[How to write good commits](https://cbea.ms/git-commit/).

